# **객체 지향 관점에서의 용어 정리**
아닌것도 껴있음~
## **클래스**  
* 객체를 만들어 내기 위한 설계도 혹은 틀  
* 연관되어 있는 변수와 메서드의 집합  

## **객체**    
* 클래스에 선언된 모양 그대로 생성된 실체  
* 클래스의 인스턴스  
  
## **인스턴스**    
* 객체 지향 프로그래밍에서 어떤 클래스에 속하는 각 객체를 표현하는 말  
* 객체가 메모리에 할당되어 실제 사용될 때 '인스턴스' 라 함  
* 인스턴스는 어떤 원본(추상적인 개념)으로부터 '생성된 복제본'을 의미
   
## **의존성**  
* 종속성 / 
* A가 B에 의존성이 있다는 것은 B의 변경 사항에 대해 A도 영향을 받는다는 것  

## **상속**  
* 부모 클래스(상위 클래스)와 자식 클래스(하위 클래스)의 관계에서 발생하며, '자식 클래스가 부모 클래스를 상속받는다.'라고 표현  
* 자식 클래스의 변경은 부모에게 영향을 주지 않는다.   
* 자식 클래스의 멤버 개수는 부모 클래스보다 항상 같거나 많다

## **추상화**
클래스를 정의할 때, 불필요한 부분들을 생략하고 객체의 속성 중 중요한 것에만 중점을 두어 개략화 하는 것, 즉 클래스들의 중요하고 공통된 성질들을 추출하여 슈퍼 클래스를 선정하는 개념.  
복잡한 시스템으로부터 핵심적인 개념/기능을 간추려 내는 것  
### **추상 메소드(abstract method)**
* 자식 클래스에서 반드시 오버라이딩해야만 사용할 수 있는 메소드
* 추상 메소드가 포함된 클래스를 상속받는 자식 클래스가 반드시 추상 메소드를 구현하도록 하기 위함
### **추상 클래스(abstract class)**
* 하나 이상의 추상 메소드를 포함하는 클래스
* 다형성을 가지는 메소드의 집합을 정의할 수 있도록 해준다
* 이 클래스를 상속받는 모든 클래스에서는 이 추상 메소드를 반드시 재정의해야 합니다.
* 추상 클래스는 동작이 정의되어 있지 않은 추상 메소드를 포함하고 있으므로, 인스턴스를 생성할 수 없습니다.
* 자식을 통해 추상 클래스를 `extends` 하고, 자식 내부에서 추상 메소드를 오버라이딩

## **인터페이스**
* 추상클래스보다 더 추상화된 클래스로 다른 클래스를 작성할 때 기본이 되는 틀을 제공하면서, 다른 클래스 사이의 중간 매개 역할까지 담당한다.
* 모든 기능을 추상화로 정의만 하고 구현은 하지 않은 것을 말한다.
* `implements` 키워드를 사용하여 인터페이스를 '상속'이 아닌 '구현'한다.
* 주로 제공할 기능을 정의하는데 사용한다.
* 인터페이스는 오로지 추상 메소드와 상수만을 포함할 수 있다.
## **다형성(polymorphism)**
하나의 메서드나 클래스가 다양한 방법으로 동작하는 것
### **오버라이딩(method overriding)**
* 상속 관계에 있는 부모 클래스에서 이미 정의된 메소드를 자식 클래스에서 같은 시그니쳐를 갖는 메소드로 다시 정의하는 것
* 런타임 중에 발생하는 동적 다형성

### **오버로딩(method overloading)**
* 같은 이름의 메소드를 중복하여 정의하는 것
* 매개변수의 개수나 타입이 달라야 함
* 컴파일 중에 발생하는 정적 다형성

## **정적 메서드(static)**
* 객체 생성없이 클래스를 통해 메서드를 직접 호출
* static 메소드 안에서는 객체변수 접근이 불가능

## **프록시 객체**
* 어떠한 대상의 기본적인 동작(속성 접근, 할당, 순회, 열거, 함수호출 등)의 작업을 가로챌 수 이는 객체를 뜻함
* (terget, handler) terget:대상  handler:가로챈 후 할 동작 함수
```js
// get(): 속성과 함수에 대한 접근 제한
// has(): in 연산자의 사용 제한
// set(): 속성에 대한 접근 제한

const handler = {
    get:function(terget, name){
        return name === 'name'?`${target.a} ${target.b}` : target[name]
    }
}
const p = new Proxy({a:"YUJIN", B:"HOJAE"}, handler)
console.log(p.name) // YUJIN HOJAE
```


## **collection**
* 프로그래밍 언어가 제공하는 값을 담을 수 있는 컨테이너 느낌~?
* 언어별로 다양하다 
> **js** :  Map, Set, WeakMap, WeakSet, Typed Array, Object, Array ..  
> **pyhton**: list, tuple, dictionaries...  
> ..

## **접근제어자**
접근 제어자를 사용하면 클래스 외부에서의 직접적인 접근을 허용하지 않는 멤버를 설정하여 정보 은닉(data hiding)을 구체화할 수 있습니다.  
  
**TS기준 접근 제어자** 
| 구분 |    선언한 클래스 내부 | 상속받은 클래스 내부 |          인스턴스 |
| --- | :---: | :---: | :---: |
| private  |                 ⭕ |                ❌   |               ❌   |
| protected |                 ⭕ |                ⭕ |               ❌   |
| public |                 ⭕ |                ⭕ |               ⭕ |


## **일급 객체**
* 다음과 같은 특징을 갖는 언어
    * 변수가 메서드에 함수를 할당할 수 있다.
    * 함수 안에 함수를 매개변수로 담을 수 있다.
    * 함수가 함수를 반환할 수 있다.

## **캡슐화**
* 객체의 속성과 메서드를 하나로 묶오 일부를 외부에 감추어 은닉하는 것

## **SOLID 설계원칙**
### 단일 책임 원칙(SRP,Single Responsiblity Principle)
* 모든 클래스에는 각각 하나의 책임만을 가져야 한다
* A라는 로직이 존재한다면 어떠한 클래스는 A에 관한 클래스야하 하고, 이를 수정한다고 해도 A와 관련된 수정이어야 한다.

### 개방-폐쇄 원칙(OCP, Open Closed Principle)
* 개체의 확장은 개방적으로, 객체의 수정은 폐쇄적으로  
* 객체간의 의존성은 최소화하되 정보은닉과 모듈화는 올바르게 구현
* 기존의 코드는 잘 변경하지 않으면서 확장은 쉽게 할 수 있어야 한다.

### 리스코프 치완 원칙(LSP, Liskov Subsitution Principle)
* 프로그램의 객체는 프로그램의 정확성을 깨트리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
* 부모 객체에 자식 객체를 넣어도 시스템이 문제없이 돌아가게 만드는 것

### 인터페이스 분리 원칙(ISP, Interface Segregation Principle)
* 하나의 일반적인 인터페이스보다 구체적인 여러개의 인터페이스를 만들어야한다는 원칙

### 의존 역전 원칙(DIP, Dependency Inversion Principle)
* 추상화에 의존해야지, 구체화에 의존하면 안된다
* 상위 계층은 하위 계층의 변화에 대한 구현으로부터 독립돼야 한다.
* 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것에 영향받지 않게 하는 원칙